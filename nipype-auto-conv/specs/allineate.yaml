# This file is used to manually specify the semi-automatic conversion of
# 'nipype.interfaces.afni.preprocess.Allineate' from Nipype to Pydra.
#
# Please fill-in/edit the fields below where appropriate
#
# Inputs
# ------
# in_file : file
#    input file to 3dAllineate
# reference : file
#    file to be used as reference, the first volume will be used if not given the reference will be the first volume of in_file.
# out_file : file
#    output file from 3dAllineate
# out_param_file : file
#    Save the warp parameters in ASCII (.1D) format.
# in_param_file : file
#    Read warp parameters from file and apply them to the source dataset, and produce a new dataset
# out_matrix : file
#    Save the transformation matrix for each volume.
# in_matrix : file
#    matrix to align input file
# overwrite : bool
#    overwrite output file if it already exists
# allcostx : file
#    Compute and print ALL available cost functionals for the un-warped inputsAND THEN QUIT. If you use this option none of the other expected outputs will be produced
# cost : enum
#    Defines the 'cost' function that defines the matching between the source and the base
# interpolation : enum
#    Defines interpolation method to use during matching
# final_interpolation : enum
#    Defines interpolation method used to create the output dataset
# nmatch : int
#    Use at most n scattered points to match the datasets.
# no_pad : bool
#    Do not use zero-padding on the base image.
# zclip : bool
#    Replace negative values in the input datasets (source & base) with zero.
# convergence : float
#    Convergence test in millimeters (default 0.05mm).
# usetemp : bool
#    temporary file use
# check : list
#    After cost functional optimization is done, start at the final parameters and RE-optimize using this new cost functions. If the results are too different, a warning message will be printed. However, the final parameters from the original optimization will be used to create the output dataset.
# one_pass : bool
#    Use only the refining pass -- do not try a coarse resolution pass first.  Useful if you know that only small amounts of image alignment are needed.
# two_pass : bool
#    Use a two pass alignment strategy for all volumes, searching for a large rotation+shift and then refining the alignment.
# two_blur : float
#    Set the blurring radius for the first pass in mm.
# two_first : bool
#    Use -twopass on the first image to be registered, and then on all subsequent images from the source dataset, use results from the first image's coarse pass to start the fine pass.
# two_best : int
#    In the coarse pass, use the best 'bb' set of initialpoints to search for the starting point for the finepass.  If bb==0, then no search is made for the beststarting point, and the identity transformation isused as the starting point.  [Default=5; min=0 max=11]
# fine_blur : float
#    Set the blurring radius to use in the fine resolution pass to 'x' mm.  A small amount (1-2 mm?) of blurring at the fine step may help with convergence, if there is some problem, especially if the base volume is very noisy. [Default == 0 mm = no blurring at the final alignment pass]
# center_of_mass : str
#    Use the center-of-mass calculation to bracket the shifts.
# autoweight : str
#    Compute a weight function using the 3dAutomask algorithm plus some blurring of the base image.
# automask : int
#    Compute a mask function, set a value for dilation or 0.
# autobox : bool
#    Expand the -automask function to enclose a rectangular box that holds the irregular mask.
# nomask : bool
#    Don't compute the autoweight/mask; if -weight is not also used, then every voxel will be counted equally.
# weight_file : file
#    Set the weighting for each voxel in the base dataset; larger weights mean that voxel count more in the cost function. Must be defined on the same grid as the base dataset
# weight : traitcompound
#    Set the weighting for each voxel in the base dataset; larger weights mean that voxel count more in the cost function. If an image file is given, the volume must be defined on the same grid as the base dataset
# out_weight_file : file
#    Write the weight volume to disk as a dataset
# source_mask : file
#    mask the input dataset
# source_automask : int
#    Automatically mask the source dataset with dilation or 0.
# warp_type : enum
#    Set the warp type.
# warpfreeze : bool
#    Freeze the non-rigid body parameters after first volume.
# replacebase : bool
#    If the source has more than one volume, then after the first volume is aligned to the base.
# replacemeth : enum
#    After first volume is aligned, switch method for later volumes. For use with '-replacebase'.
# epi : bool
#    Treat the source dataset as being composed of warped EPI slices, and the base as comprising anatomically 'true' images.  Only phase-encoding direction image shearing and scaling will be allowed with this option.
# maxrot : float
#    Maximum allowed rotation in degrees.
# maxshf : float
#    Maximum allowed shift in mm.
# maxscl : float
#    Maximum allowed scaling factor.
# maxshr : float
#    Maximum allowed shearing factor.
# master : file
#    Write the output dataset on the same grid as this file.
# newgrid : float
#    Write the output dataset using isotropic grid spacing in mm.
# nwarp : enum
#    Experimental nonlinear warping: bilinear or legendre poly.
# nwarp_fixmot : list
#    To fix motion along directions.
# nwarp_fixdep : list
#    To fix non-linear warp dependency along directions.
# verbose : bool
#    Print out verbose progress reports.
# quiet : bool
#    Don't print out verbose progress reports.
# num_threads : int
#    set number of threads
# outputtype : enum
#    AFNI output filetype
# args : str
#    Additional parameters to the command
# environ : dict
#    Environment variables
#
# Outputs
# -------
# out_file : file
#    output image file name
# out_matrix : file
#    matrix to align input file
# out_param_file : file
#    warp parameters
# out_weight_file : file
#    weight volume
# allcostx : file
#    Compute and print ALL available cost functionals for the un-warped inputs
#
# Docs
# ----
# Program to align one dataset (the 'source') to a base dataset
# 
#     For complete details, see the `3dAllineate Documentation.
#     <https://afni.nimh.nih.gov/pub/dist/doc/program_help/3dAllineate.html>`_
# 
#     Examples
#     --------
#     >>> from nipype.interfaces import afni
#     >>> allineate = afni.Allineate()
#     >>> allineate.inputs.in_file = 'functional.nii'
#     >>> allineate.inputs.out_file = 'functional_allineate.nii'
#     >>> allineate.inputs.in_matrix = 'cmatrix.mat'
#     >>> allineate.cmdline
#     '3dAllineate -source functional.nii -prefix functional_allineate.nii -1Dmatrix_apply cmatrix.mat'
#     >>> res = allineate.run()  # doctest: +SKIP
# 
#     >>> allineate = afni.Allineate()
#     >>> allineate.inputs.in_file = 'functional.nii'
#     >>> allineate.inputs.reference = 'structural.nii'
#     >>> allineate.inputs.allcostx = 'out.allcostX.txt'
#     >>> allineate.cmdline
#     '3dAllineate -source functional.nii -base structural.nii -allcostx |& tee out.allcostX.txt'
#     >>> res = allineate.run()  # doctest: +SKIP
# 
#     >>> allineate = afni.Allineate()
#     >>> allineate.inputs.in_file = 'functional.nii'
#     >>> allineate.inputs.reference = 'structural.nii'
#     >>> allineate.inputs.nwarp_fixmot = ['X', 'Y']
#     >>> allineate.cmdline
#     '3dAllineate -source functional.nii -nwarp_fixmotX -nwarp_fixmotY -prefix functional_allineate -base structural.nii'
#     >>> res = allineate.run()  # doctest: +SKIP
#     
task_name: allineate
nipype_name: Allineate
nipype_module: nipype.interfaces.afni.preprocess
inputs:
  omit:
  # list[str] - fields to omit from the Pydra interface
  rename:
  # dict[str, str] - fields to rename in the Pydra interface
  types:
  # dict[str, type] - override inferred types (use "mime-like" string for file-format types,
  # e.g. 'medimage/nifti-gz'). For most fields the type will be correctly inferred
  # from the nipype interface, but you may want to be more specific, particularly
  # for file types, where specifying the format also specifies the file that will be
  # passed to the field in the automatically generated unittests.
    in_file: medimage/nifti1
    reference: medimage/nifti1
    out_file: medimage/nifti1
    out_param_file: generic/file
    in_param_file: generic/file
    out_matrix: generic/file
    in_matrix: datascience/mat-file
    allcostx: text/text-file
    weight_file: generic/file
    out_weight_file: generic/file
    source_mask: generic/file
    master: generic/file
  metadata:
  # dict[str, dict[str, any]] - additional metadata to set on any of the input fields (e.g. out_file: position: 1)
outputs:
  omit:
  # list[str] - fields to omit from the Pydra interface
  rename:
  # dict[str, str] - fields to rename in the Pydra interface
  types:
  # dict[str, type] - override inferred types (use "mime-like" string for file-format types,
  # e.g. 'medimage/nifti-gz'). For most fields the type will be correctly inferred
  # from the nipype interface, but you may want to be more specific, particularly
  # for file types, where specifying the format also specifies the file that will be
  # passed to the field in the automatically generated unittests.
    out_file: medimage/nifti1
    out_matrix: generic/file
    out_param_file: generic/file
    out_weight_file: generic/file
    allcostx: text/text-file
  callables:
  # dict[str, str] - names of methods/callable classes defined in the adjacent `*_callables.py`
  # to set to the `callable` attribute of output fields
  templates:
  # dict[str, str] - `output_file_template` values to be provided to output fields
  requirements:
  # dict[str, list[str]] - input fields that are required to be provided for the output field to be present
tests:
- inputs:
  # dict[str, str] - values to provide to inputs fields in the task initialisation
  # (if not specified, will try to choose a sensible value)
    in_file:
    out_file:
    in_matrix:
  imports:
  # list[nipype2pydra.task.importstatement] - list import statements required by the test, with each list item
  # consisting of 'module', 'name', and optionally 'alias' keys
  expected_outputs:
  # dict[str, str] - expected values for selected outputs, noting that tests will typically
  # be terminated before they complete for time-saving reasons, and therefore
  # these values will be ignored, when running in CI
  timeout: 10
  # int - the value to set for the timeout in the generated test, 
  # after which the test will be considered to have been initialised 
  # successfully. Set to 0 to disable the timeout (warning, this could
  # lead to the unittests taking a very long time to complete)
  xfail: true
  # bool - whether the unittest is expected to fail or not. Set to false
  # when you are satisfied with the edits you have made to this file
- inputs:
  # dict[str, str] - values to provide to inputs fields in the task initialisation
  # (if not specified, will try to choose a sensible value)
    in_file:
    reference:
    allcostx:
  imports:
  # list[nipype2pydra.task.importstatement] - list import statements required by the test, with each list item
  # consisting of 'module', 'name', and optionally 'alias' keys
  expected_outputs:
  # dict[str, str] - expected values for selected outputs, noting that tests will typically
  # be terminated before they complete for time-saving reasons, and therefore
  # these values will be ignored, when running in CI
  timeout: 10
  # int - the value to set for the timeout in the generated test, 
  # after which the test will be considered to have been initialised 
  # successfully. Set to 0 to disable the timeout (warning, this could
  # lead to the unittests taking a very long time to complete)
  xfail: true
  # bool - whether the unittest is expected to fail or not. Set to false
  # when you are satisfied with the edits you have made to this file
- inputs:
  # dict[str, str] - values to provide to inputs fields in the task initialisation
  # (if not specified, will try to choose a sensible value)
    in_file:
    reference:
    nwarp_fixmot: '["X", "Y"]'
  imports:
  # list[nipype2pydra.task.importstatement] - list import statements required by the test, with each list item
  # consisting of 'module', 'name', and optionally 'alias' keys
  expected_outputs:
  # dict[str, str] - expected values for selected outputs, noting that tests will typically
  # be terminated before they complete for time-saving reasons, and therefore
  # these values will be ignored, when running in CI
  timeout: 10
  # int - the value to set for the timeout in the generated test, 
  # after which the test will be considered to have been initialised 
  # successfully. Set to 0 to disable the timeout (warning, this could
  # lead to the unittests taking a very long time to complete)
  xfail: true
  # bool - whether the unittest is expected to fail or not. Set to false
  # when you are satisfied with the edits you have made to this file
doctests:
- cmdline: 3dAllineate -source functional.nii -prefix functional_allineate.nii -1Dmatrix_apply cmatrix.mat
  # str - the expected cmdline output
  inputs:
  # dict[str, str] - name-value pairs for inputs to be provided to the doctest.
  # If the field is of file-format type and the value is None, then the
  # '.mock()' method of the corresponding class is used instead.
    in_file:
    out_file:
    in_matrix:
  imports:
  # list[nipype2pydra.task.importstatement] - list import statements required by the test, with each list item
  # consisting of 'module', 'name', and optionally 'alias' keys
  directive: ''''
  # str - any doctest directive to place on the cmdline call, e.g. # doctest: +ELLIPSIS
- cmdline: 3dAllineate -source functional.nii -base structural.nii -allcostx |& tee out.allcostX.txt
  # str - the expected cmdline output
  inputs:
  # dict[str, str] - name-value pairs for inputs to be provided to the doctest.
  # If the field is of file-format type and the value is None, then the
  # '.mock()' method of the corresponding class is used instead.
    in_file:
    reference:
    allcostx:
  imports:
  # list[nipype2pydra.task.importstatement] - list import statements required by the test, with each list item
  # consisting of 'module', 'name', and optionally 'alias' keys
  directive: ''''
  # str - any doctest directive to place on the cmdline call, e.g. # doctest: +ELLIPSIS
- cmdline: 3dAllineate -source functional.nii -nwarp_fixmotX -nwarp_fixmotY -prefix functional_allineate -base structural.nii
  # str - the expected cmdline output
  inputs:
  # dict[str, str] - name-value pairs for inputs to be provided to the doctest.
  # If the field is of file-format type and the value is None, then the
  # '.mock()' method of the corresponding class is used instead.
    in_file:
    reference:
    nwarp_fixmot: '["X", "Y"]'
  imports:
  # list[nipype2pydra.task.importstatement] - list import statements required by the test, with each list item
  # consisting of 'module', 'name', and optionally 'alias' keys
  directive: ''''
  # str - any doctest directive to place on the cmdline call, e.g. # doctest: +ELLIPSIS
